入门操作：
   rustc main.rs
   main.exe

进阶操作：
   使用Cargo创建项目：
   cargo new hello_cargo
   - 项目的名字也是 hello_cargo
   - 会创建一个新的目录 hello_cargo
   - Cargo.toml
   - src 目录
      - main.rs

[Cargo.toml]
   - toml(Tom's Obvious,Minimal Language) 格式，是 Cargo 的配置格式

[pacakge]
   - 是一个区域标题，表示下方内容是用来配置包[package]的
   - name 项目名
   - version 项目版本
   - authors 项目作者
   - edition 使用的rust版本

[dependencies]
   - 另一个区域的开始，它会列出项目的依赖项

[注] 在 Rust 里面，代码的包称作 crate

[常用指令]
   - cargo build
   - cargo bulid --release 为发布构建 代码运行更快，编译时间较长
   - cargo run 编译+运行
   - cargo check 检查代码，确保能通过编译，不产生二进制文件
   - cargo update 更新依赖项
   - rustup doc 本地文档
   - cargo doc --open 本地依赖项 crate 文档

[变量与可变性]
   - 声明变量使用 let 关键字
   - 默认情况下，变量是不可变的(Immutable)
   - 在变量前面加上 mut 关键字 就可变为可变变量

[变量与常量]
   -- 常量(constant)，常量在绑定值以后也是不可变的，但是它与不可变的变量有很多区别
   - 不可以使用 mut，常量永远都是不可变的
   - 声明变量使用 const 关键字，他的类型必须被标注
   - 常量可以在任何作用域内进行声明，包括全局作用域
   - 常量只可以绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算出的值
   -- 在程序运行期间，常量在其声明的作用域内一直有效
   -- 命名规范： Rust 里常量使用全大写字母，每个单词之间用下划线分开，例如：
   - MAX_POINTS
   -- const MAX_POINTS:u32 = 100_000;

[Shadowing]隐藏
   -- 可以使用相同名字声明新的变量，新的变量就会 shadow 之前声明的同名变量
   - 在后续的代码中这个变量名代表的就是新的变量
   -- shadow 和把变量标记为 mut 是不一样的：
   - 如果不使用 let 关键字，那么重新给非 mut 的变量赋值会导致编译错误
   - 而使用 let 声明的同名新变量，也是不可变的
   - 使用 let 声明的同名新变量，他的类型可以与之前不同

[数据类型]
   -- 标量和复合类型
   -- Rust 是静态编译语言，在编译时必须知道所有变量的类型
   - 基于使用的值，编译器通常能够推断出它的具体类型
   - 但如果可能的类型比较多(例如把 String 转为整数的 parse 方法)，就必须添加类型的标注，否则编译会报错

[标量类型]
   -- 一个标量类型代表一个单个的值
   -- Rust 有四个主要的标量类型
   - 整数类型
   - 浮点类型
   - 布尔类型
   - 字符类型

[整数类型]
   -- 整数类型没有小数部分
   -- 例如 u32 就是一个无符号的整数类型，占据32位的空间
   -- 无符号整数类型以 u 开头
   -- 有符号整数类型以 i 开头
   -- Rust 的整数类型列表如图
      -- -- -- -- -- -- -- -- --
      Length   Signed   Unsigned
      -- -- -- -- -- -- -- -- --
      8-bit    i8       u8
      16-bit   i16      u16
      32-bit   i32      u32
      64-bit   i64      u64
      128-bit  i128     u128
      arch     isize    usize
      -- -- -- -- -- -- -- -- --
   - 每种都分 i 和 u，以及固定的位数
   - 有符号范围： - (2^n - 1) 到 2^(n - 1) - 1
   - 无符号范围： 0 到 2^n - 1

[isize 和 usize 类型]
   -- isize 和 usize 类型的位数由程序运行的计算机的架构所决定：
   - 如果是 64 位计算机，那就是 64 位
   - ...
   -- 使用 isize 或 usize 的主要场景是对某种集合进行索引操作

[整数字面值]
   -- -- -- -- -- -- -- -- --
   Number literals   Example
   -- -- -- -- -- -- -- -- --
   Decimal           98_222
   Hex               0xff
   Octal             0o77
   Binary            0b1111_0000
   Byte(u8 only)     b'A'
   -- -- -- -- -- -- -- -- --

   -- 除了 byte 类型外，所有的数值字面值都允许使用类型后缀
   - 例如 57u8
   -- 如果你不太清楚应该使用那种类型，可以使用 Rust 相应的默认类型：
   -- 整数的默认类型就是 i32：
   - 总体上来说速度很快，即使在64位系统中

[整数溢出]
   -- 例如： u8 的范围是 0-255，如果你把一个 u8 变量的值设为256，那么：
   - 调试模式下编译：Rust 会检查整数溢出，如果发生溢出，程序在运行时就会 panic
   - 发布模式下(--release)编译：Rust 不会检查可能导致 panic 的整数溢出
      - 如果溢出发生：Rust 会执行“环绕”操作：
         - 256变成0，257变成1 ...
      - 但程序不会 panic

[浮点类型]
   -- Rust 有两种基础的浮点类型，也就是含有小数部分的类型
      - f32，32位，单精度
      - f64，64位，双精度
   -- Rust 的浮点类型使用了 IEEE-754 标准类表述
   -- f64 是默认类型，因为在现代 CPU 上f64和f32的速度差不多，而且精度更高

[数值操作]
   -- 加减乘除 取余

[布尔类型]
   -- Rust 的布尔类型也有两个值：true 和 false
   -- 一个字节大小
   -- 符号是 bool

[字符类型]
   -- Rust 语言中 char 类型被用来描述语言中最基础的单个字符。
   -- 字符类型的字面值使用单引号
   -- 占用4字节大小
   -- 是 Unicode 标量值，可以表示比 ASCLL 多得多的字符内容：拼音、中日韩文、零长度空白字符、emoji 表情等
      - U+0000 到 U+D7FF
      - U+E000 到 U+10FFF
   -- 但 Unicode 中并没有“字符”的概念，所以直觉上认为的字符也许与 Rust 中的概念并不相符

3.3 [复合类型]
   -- 复合类型可以将多个值放在一个类型里
   -- Rust 提供了两个基础的复合类型：元组(Tuple)、数组

[Tuple]
   -- Tuple 可以将多个类型的多个值放在一个类型里
   -- Tuple 的长度是固定的：一旦声明就无法更改

[创建 Tuple]
   -- 在小括号里，将值用逗号分开
   -- Tuple 中的每个位置都对应一个类型，Tuple中各元素的类型不必相同
      - let tup: (i32, f64) = (500, 5.3);

[获取 Tuple 的元素值]
   -- 可以使用模式匹配来解构(destructure)一个 Tuple 来获取元素的值
      - let (x, y, z) = tup;

[访问 Tuple 的元素]
   -- 在 Tuple 变量使用点标记法，后接元素的索引号
      - println!("{}, {}, {}", tup.0, tup.1, tup.3);

[数组]
   -- 数组也可以将多个值放在一个类型里
   -- 数组中的每个元素的类型必须相同
   -- 数组的长度也是固定的

[声明一个数组]
   -- 在中括号里，各个值用逗号分开
      - let a = [1, 2, 3];

[数组的用处]
   -- 如果想让你的数据存放在 stack(栈)上而不是 heap(堆)上，或者想保证有固定数量的元素，这时使用数组更有好处
   -- 数组没有 Vector 灵活
      - Vector 和数组类似，它由标准库提供
      - Vector 的长度可以改变
      - 如果你不确定应该用数组还是 Vector，那么估计你应该用 Vector

[数组的类型]
   -- [类型; 长度]
      - let a:[i32; 3] = [1, 2, 3];

[另一种声明数组的方法]
   -- 如果数组的每个元素值都相同，那么可以在：
      - 在中括号里指定初始值
      - 然后是一个“;”
      - 最后是数组的长度
   -- 例如： let a =[3; 3];它就相当于 let a = [3,3,3];

[访问数组的元素]
   -- 数组是 Stack 上分配的单个块的内存
   -- 可以使用索引来访问数组的元素
      - let first = months[0];
   -- 如果访问的索引超出了数组的范围，那么：
      - 编译会通过
      - 运行会报错(runtime 时会 panic)
         - Rust 不会允许其继续访问相应地址的内存

3.4 [函数]
   -- 声明函数使用 fn 关键字
   -- 依照惯例，针对函数和变量名，Rust 使用 snake case 命名规范
      - 所有的字母都是小写的，单词之间使用下划线分开
      - fn another_function(){}

[函数的参数]
   -- parameters, arguments
   -- 在函数签名里，必须声明每个参数的类型

[函数体中的语句和表达式]
   -- 函数体由一系列语句组成，可选的由一个表达式结束
   -- Rust 是一个基于表达式的语言
   -- 语句是执行一些动作的指令
   -- 表达式会计算产生一个值
   -- 函数的定义也是语句
   -- 语句不返回值，所以不可以使用 let 将一个语句赋值给一个变量

[函数的返回值]
   -- 在 -> 符号后边声明函数返回值的类型，但是不可以为返回值命名
   -- 在 Rust 里面，返回值就是函数体里面最后一个表达式的值
   -- 若想提前返回，需使用 return 关键字，并指定一个值
      - 大多数函数都是默认使用最后一个表达式作为返回值

[注释]
   -- 与大多数一样

3.5 [控制流：if else]
   -- if 表达式允许您根据条件来执行不同的代码分支
      - 这个条件必须是 bool 类型
   -- if 表达式中，与条件相关联的代码块就叫做分支(arm)
   -- 可选的，在后边可以加上一个 else 表达式

[使用 else if 处理多重条件]
   -- 如果使用多于一个 else if，那么最好使用 match 来重构代码

3.6 [控制流：循环]
   -- Rust 提供了3种循环：loop, while 和 for

[loop 循环]
   -- loop 关键字告诉 Rust 反复的执行一块代码，直到你喊停为止
   -- 可以在 loop 循环中使用 break 关键字来告诉程序何时停止循环

[while 条件循环]
   -- 另外一个常见的循环模式是每次执行之前都判断依次条件
   -- while 条件循环为这种模式而生

[使用 for 循环遍历集合]
   -- 可以使用 while 或 loop 来遍历集合，但是易错且低效
   -- 使用 for 循环更简洁紧凑，它可以针对集合中的每个元素来执行一些代码
   -- 由于 for 循环的安全、简洁性，所以它在 Rust 里用的最多

[Range]
   -- 标准库提供
   -- 指定一个开始数字和一个结束数字，range 可以生成它们之间的数字(不含结束)
   -- rev 方法可以反转 Range